{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE NamedFieldPuns    #-}
{-# LANGUAGE OverloadedStrings #-}

module Data.Morpheus.Document.RenderHaskell
  ( renderHaskellDocument
  ) where

import           Data.ByteString.Lazy.Char8             (ByteString)
import           Data.Semigroup                         ((<>))
import           Data.Text                              (Text, intercalate)
import qualified Data.Text                              as T (concat)
import qualified Data.Text.Lazy                         as LT (fromStrict)
import           Data.Text.Lazy.Encoding                (encodeUtf8)

-- MORPHEUS
import           Data.Morpheus.Document.Rendering.Terms (renderAssignment, renderCon, renderExtension, renderReturn,
                                                         renderSet, renderUnionCon)
import           Data.Morpheus.Document.Rendering.Types (renderType)
import           Data.Morpheus.Types.Internal.Data      (DataField (..), DataFullType (..), DataLeaf (..),
                                                         DataType (..), DataTypeLib (..), DataTypeWrapper (..),
                                                         allDataTypes)

renderHaskellDocument :: DataTypeLib -> ByteString
renderHaskellDocument lib =
  encodeText $ renderLanguageExtensions <> renderExports <> renderImports <> renderAPI lib <> types
  where
    encodeText = encodeUtf8 . LT.fromStrict
    types = intercalate "\n\n" $ map (renderType <> const "\n\n" <> renderResolver) visibleTypes
    visibleTypes = allDataTypes lib

renderLanguageExtensions :: Text
renderLanguageExtensions = T.concat (map renderExtension extensions) <> "\n"
  where
    extensions = ["OverloadedStrings", "DeriveGeneric", "TypeFamilies"]

renderExports :: Text
renderExports = "-- generated by 'Morpheus' CLI\n" <> "module Schema (rootResolver) where\n\n"

renderImports :: Text
renderImports = T.concat (map renderImport imports) <> "\n"
  where
    renderImport (src, list) = "import  " <> src <> "  (" <> intercalate ", " list <> ")\n"
    --------------------------------------------------------------------------------------
    imports =
      [ ("GHC.Generics", ["Generic"])
      , ("Data.Morpheus.Kind", ["SCALAR", "ENUM", "INPUT_OBJECT", "OBJECT", "UNION"])
      , ("Data.Morpheus.Types", ["GQLRootResolver(..)", "StreamM", "ResM", "GQLType(..)"])
      , ("Data.Text", ["Text"])
      ]

renderAPI :: DataTypeLib -> Text
renderAPI DataTypeLib {mutation, subscription} = renderSignature <> renderBody <> "\n\n"
  where
    renderSignature =
      "rootResolver :: GQLRootResolver IO () Query " <> maybeOperator mutation <> " " <> maybeOperator subscription <>
      "\n"
      where
        maybeOperator (Just (name, _)) = name
        maybeOperator Nothing          = "()"
    renderBody = "rootResolver =\n  GQLRootResolver" <> renderResObject fields
      where
        fields =
          [ ("queryResolver", "resolveQuery")
          , ("mutationResolver", maybeRes mutation)
          , ("subscriptionResolver", maybeRes subscription)
          ]
      ---------------------------------------------
        maybeRes (Just (name, _)) = "resolve" <> name
        maybeRes Nothing          = "return ()"

renderResObject :: [(Text, Text)] -> Text
renderResObject = renderSet . map renderEntry
  where
    renderEntry (key, value) = key <> " = " <> value

renderResolver :: (Text, DataFullType) -> Text
renderResolver (name, dataType) = renderSig dataType
  where
    renderSig (Leaf LeafScalar {}) = defFunc <> renderReturn <> "$ " <> renderCon name <> "0 0"
    renderSig (Leaf (LeafEnum DataType {typeData})) = defFunc <> renderReturn <> renderCon (head typeData)
    renderSig (Union DataType {typeData}) = defFunc <> renderUnionCon name typeCon <> " <$> " <> "resolve" <> typeCon
      where
        typeCon = fieldType $ head typeData
    renderSig (OutputObject DataType {typeData}) = defFunc <> renderReturn <> renderCon name <> renderObjFields
      where
        renderObjFields = renderResObject (map renderFieldRes typeData)
        renderFieldRes (key, DataField {fieldType, fieldTypeWrappers}) =
          (key, "const " <> renderValue fieldTypeWrappers fieldType)
          where
            renderValue []                            = const $ "$ " <> renderReturn <> "Nothing"
            renderValue [NonNullType]                 = fieldValue
            renderValue (ListType:_)                  = const $ "$ " <> renderReturn <> "Just []"
            renderValue (NonNullType:(ListType:_))    = const $ "$ " <> renderReturn <> "[]"
            renderValue (NonNullType:(NonNullType:_)) = const "Error: should not Happen"
            fieldValue "String" = "$ return \"\""
            fieldValue "Int"    = "$ return 0"
            fieldValue fName    = "resolve" <> fName
    renderSig _ = "" -- INPUT Types Does not Need Resolvers
    --------------------------------
    defFunc = renderSignature <> renderFunc
    ----------------------------------------------------------------------------------------------------------
    renderSignature = renderAssignment ("resolve" <> name) (renderMonad name) <> "\n"
    ---------------------------------------------------------------------------------
    renderMonad "Mutation" = "StreamM () Mutation"
    renderMonad tName      = "ResM " <> tName
    ----------------------------------------------------------------------------------------------------------
    renderFunc = "resolve" <> name <> " = "
    ---------------------------------------
