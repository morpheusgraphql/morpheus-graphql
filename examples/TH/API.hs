{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE NamedFieldPuns    #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE TypeFamilies      #-}

module TH.API
  ( thApi
  ) where

import qualified Data.ByteString.Lazy.Char8 as B
import           Data.Text                  (Text)
import           GHC.Generics               (Generic)

-- MORPHEUS
import           Data.Morpheus              (interpreter)
import           Data.Morpheus.Document     (gqlDocument)
import           Data.Morpheus.Kind         (SCALAR)
import           Data.Morpheus.Types        (GQLRootResolver (..), GQLScalar (..), GQLType (..), ID, IORes,
                                             ScalarValue (..))

newtype Euro =
  Euro Int
  deriving (Show, Generic)

instance GQLType Euro where
  type KIND Euro = SCALAR

instance GQLScalar Euro where
  parseValue _ = pure (Euro 0)
  serialize (Euro x) = Int (x * 100)

[gqlDocument|
   # GraphQL  Types Generated By Template Haskell

  type Query {
    user : User!
  }

  type User {
    name                                      : Text!
    email                                     : Text!
    address (zipCode: UID!, cityID : CityID ) : Address!
    myUnion (coordinates: Coordinates)        : MyUnion!
    home                                      : CityID!
  }

  type Address {
    city        : Text!
    street      : Text!
    houseNumber : Int!
  }

  union MyUnion = User | Address

  enum CityID {
    Paris
    BLN
    HH
  }

  input Coordinates {
    latitude  : Euro!
    longitude : [[UID!]]!
  }

  # simple.gql
  interface Node {
      nodeId: ID!
  }

  type SimpleType implements Node {
    nodeId: ID!
    interfaceName: String!
  }

  input UID {
    uid: Text!
  }
|]

gqlRoot :: GQLRootResolver IO () () Query () ()
gqlRoot = GQLRootResolver {queryResolver, mutationResolver = return (), subscriptionResolver = return ()}
  where
    queryResolver :: IORes Query
    queryResolver = return Query {user}
      where
        user :: () -> IORes User
        user _ =
          return
            User
              { name = const $ pure "David"
              , email = const $ pure "David@email.com"
              , address
              , home = const $ pure HH
              , myUnion = const $ pure $ MyUnionAddress $ simpleAddress "boo"
              }
        address :: AddressArgs -> IORes Address
        address AddressArgs {zipCode = UID {uid}} = return $ simpleAddress uid
        --------------------------------
        simpleAddress streetID =
          Address {city = const $ pure "Hamburg", street = const $ pure streetID, houseNumber = const $ pure 20}

thApi :: B.ByteString -> IO B.ByteString
thApi = interpreter gqlRoot
