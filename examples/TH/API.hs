{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE NamedFieldPuns     #-}
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE PolyKinds          #-}
{-# LANGUAGE QuasiQuotes        #-}
{-# LANGUAGE RankNTypes         #-}
{-# LANGUAGE TemplateHaskell    #-}
{-# LANGUAGE TypeFamilies       #-}
{-# LANGUAGE TypeInType         #-}
{-# LANGUAGE TypeOperators      #-}

module TH.API
  ( thApi
  ) where

import qualified Data.ByteString.Lazy.Char8 as B
import           Data.Text                  (Text)
import           Data.Typeable              (Typeable)
import           GHC.Generics               (Generic)

-- MORPHEUS
import           Data.Morpheus              (interpreter)
import           Data.Morpheus.Document     (gqlDoc)
import           Data.Morpheus.Kind         (ENUM, INPUT_OBJECT, INPUT_UNION, OBJECT, SCALAR, UNION)
import           Data.Morpheus.Types        (Event (..), GQLRootResolver (..), GQLScalar (..), GQLType (..), ID,
                                             IOMutRes, IORes, IOSubRes, Resolver, ScalarValue (..), mutResolver,
                                             resolver)

newtype UniqueID = UniqueID
  { uid :: Text
  } deriving (Show, Generic)

instance GQLType UniqueID where
  type KIND UniqueID = INPUT_OBJECT

data MyUnion res
  = USER (User res)
  | ADDRESS Address
  deriving (Generic)

instance Typeable a => GQLType (MyUnion a) where
  type KIND (MyUnion a) = UNION

data CityID
  = Paris
  | BLN
  | HH
  deriving (Generic)

instance GQLType CityID where
  type KIND CityID = ENUM

data Euro =
  Euro Int
       Int
  deriving (Generic)

instance GQLType Euro where
  type KIND Euro = SCALAR

instance GQLScalar Euro where
  parseValue _ = pure (Euro 1 0)
  serialize (Euro x y) = Int (x * 100 + y)

data Coordinates = Coordinates
  { latitude  :: Euro
  , longitude :: [Maybe [[UniqueID]]]
  } deriving (Generic)

instance GQLType Coordinates where
  type KIND Coordinates = INPUT_OBJECT
  description _ = "just random latitude and longitude"

data Address = Address
  { city        :: Text
  , street      :: Text
  , houseNumber :: Int
  } deriving (Generic)

instance GQLType Address where
  type KIND Address = OBJECT

data AddressArgs = AddressArgs
  { coordinates :: Coordinates
  , comment     :: Maybe Text
  } deriving (Generic)

data OfficeArgs = OfficeArgs
  { zipCode :: Maybe [[Maybe [ID]]]
  , cityID  :: CityID
  } deriving (Generic)

data User m = User
  { name    :: Text
  , email   :: Text
  , address :: AddressArgs -> m Address
  , myUnion :: () -> m (MyUnion m)
  , home    :: CityID
  } deriving (Generic)

instance Typeable a => GQLType (User a) where
  type KIND (User a) = OBJECT
  description _ = "Custom Description for Client Defined User Type"

fetchAddress :: Monad m => Euro -> m (Either String Address)
fetchAddress _ = return $ Right $ Address " " "" 0

[gqlDoc|
   # GraphQL Object Generated By Template Haskell
   type SomeObject {
     someName(arg1:Int): String!
     somePower: Int
   }

   # GraphQL Enum Generated By Template Haskell
   enum SomeEnum {
     Bobo
     Fobo
   }

   # GraphQL Union Generated By Template Haskell
   union SomeUnion = SomeObject

   input SomeInput {
      someInputField : String
   }
|]

argb :: ArgSomeName
argb = ArgSomeName {arg1 = Just 1}

someEnum :: SomeEnum
someEnum = Bobo

someInput :: SomeInput
someInput = SomeInput {someInputField = Just ""}

someObject :: SomeObject
someObject = SomeObject {someName = "", somePower = Just 1}

someUnion :: SomeUnion
someUnion = SomeUnionSomeObject someObject

fetchUser :: Monad m => m (Either String (User (Resolver m)))
fetchUser =
  return $
  Right $
  User
    { name = "George"
    , email = "George@email.com"
    , address = const resolveAddress
    , home = HH
    , myUnion = const $ return $ USER unionUser
    }
  where
    resolveAddress = resolver $ fetchAddress (Euro 1 0)
    unionAddress = Address {city = "Hamburg", street = "Street", houseNumber = 20}
    unionUser =
      User
        { name = "David"
        , email = "David@email.com"
        , address = const resolveAddress
        , home = BLN
        , myUnion = const $ return $ ADDRESS unionAddress
        }

newtype Query = Query
  { user :: () -> IORes (User IORes)
  } deriving (Generic)

gqlRoot :: GQLRootResolver IO () () Query () ()
gqlRoot =
  GQLRootResolver
    { queryResolver = return Query {user = const $ resolver fetchUser}
    , mutationResolver = return ()
    , subscriptionResolver = return ()
    }

thApi :: B.ByteString -> IO B.ByteString
thApi = interpreter gqlRoot
