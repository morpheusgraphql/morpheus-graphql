{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE NamedFieldPuns     #-}
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE PolyKinds          #-}
{-# LANGUAGE QuasiQuotes        #-}
{-# LANGUAGE RankNTypes         #-}
{-# LANGUAGE TemplateHaskell    #-}
{-# LANGUAGE TypeFamilies       #-}
{-# LANGUAGE TypeInType         #-}
{-# LANGUAGE TypeOperators      #-}

module TH.API
  ( thApi
  ) where

import qualified Data.ByteString.Lazy.Char8 as B
import           Data.Text                  (Text)
import           GHC.Generics               (Generic)

-- MORPHEUS
import           Data.Morpheus              (interpreter)
import           Data.Morpheus.Document     (gqlDoc)
import           Data.Morpheus.Kind         (ENUM, INPUT_OBJECT, OBJECT, SCALAR, UNION)
import           Data.Morpheus.Types        (GQLRootResolver (..), GQLScalar (..), GQLType (..), IORes,
                                             ScalarValue (..))

data MyUnion
  = USER User
  | ADDRESS Address
  deriving (Generic)

instance GQLType MyUnion where
  type KIND MyUnion = UNION

data Euro =
  Euro Int
       Int
  deriving (Show, Generic)

instance GQLType Euro where
  type KIND Euro = SCALAR

instance GQLScalar Euro where
  parseValue _ = pure (Euro 1 0)
  serialize (Euro x y) = Int (x * 100 + y)

[gqlDoc|
   # GraphQL  Types Generated By Template Haskell

   type Address {
     city        : Text!
     street      : Text!
     houseNumber : Int!
   }

   type User {
     name    : Text!
     email   : Text!
     address ( zipCodes : [UID!] , cityID  : CityID ) : Address!
     myUnion : MyUnion!
     home    : CityID!
   }

   union SomeUnion = Address

   enum CityID {
      Paris
      BLN
      HH
   }

   input Coordinates {
      latitude  : Euro!
      longitude : [[UID!]]!
   }

   input UID {
     uid: Text
   }
|]

fetchUser :: IORes User
fetchUser =
  return $
  User
    { name = const $ pure "George"
    , email = const $ pure "George@email.com"
    , address
    , home = const $ pure HH
    , myUnion = const $ return $ USER unionUser
    }
  where
    address :: a -> IORes Address
    address _ = return simpleAddress
    simpleAddress =
      Address {city = const $ pure "Hamburg", street = const $ pure "Street", houseNumber = const $ pure 20}
    unionUser =
      User
        { name = const $ pure "David"
        , email = const $ pure "David@email.com"
        , address
        , home = const $ pure BLN
        , myUnion = const $ pure $ ADDRESS simpleAddress
        }

newtype Query = Query
  { user :: () -> IORes User
  } deriving (Generic)

gqlRoot :: GQLRootResolver IO () () Query () ()
gqlRoot =
  GQLRootResolver
    { queryResolver = return Query {user = const fetchUser}
    , mutationResolver = return ()
    , subscriptionResolver = return ()
    }

thApi :: B.ByteString -> IO B.ByteString
thApi = interpreter gqlRoot
