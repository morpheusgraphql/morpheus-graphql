{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE NamedFieldPuns     #-}
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE PolyKinds          #-}
{-# LANGUAGE QuasiQuotes        #-}
{-# LANGUAGE RankNTypes         #-}
{-# LANGUAGE TemplateHaskell    #-}
{-# LANGUAGE TypeFamilies       #-}
{-# LANGUAGE TypeInType         #-}
{-# LANGUAGE TypeOperators      #-}

module TH.API
  ( thApi
  ) where

import qualified Data.ByteString.Lazy.Char8 as B
import           Data.Text                  (Text)
import           GHC.Generics               (Generic)

-- MORPHEUS
import           Data.Morpheus              (interpreter)
import           Data.Morpheus.Document     (gqlDoc)
import           Data.Morpheus.Kind         (ENUM, INPUT_OBJECT, OBJECT, SCALAR, UNION)
import           Data.Morpheus.Types        (GQLRootResolver (..), GQLScalar (..), GQLType (..), IORes,
                                             ScalarValue (..))

data Euro =
  Euro Int
       Int
  deriving (Show, Generic)

instance GQLType Euro where
  type KIND Euro = SCALAR

instance GQLScalar Euro where
  parseValue _ = pure (Euro 1 0)
  serialize (Euro x y) = Int (x * 100 + y)

[gqlDoc|
   # GraphQL  Types Generated By Template Haskell
  type Query {
    user : User!
  }

  type User {
    name    : Text!
    email   : Text!
    address ( zipCodes : [UID!] , cityID  : CityID ) : Address!
    myUnion : MyUnion!
    home    : CityID!
  }

  type Address {
    city        : Text!
    street      : Text!
    houseNumber : Int!
  }

  union MyUnion = User | Address

  enum CityID {
    Paris
    BLN
    HH
  }

  input Coordinates {
    latitude  : Euro!
    longitude : [[UID!]]!
  }

  input UID {
    uid: Text
  }
|]

resolveQuery :: IORes Query
resolveQuery = return Query {user = resolveUser}
  where
    resolveUser _ =
      return
        User
          { name = const $ pure "George"
          , email = const $ pure "George@email.com"
          , address
          , home = const $ pure HH
          , myUnion = const $ pure $ MyUnionAddress simpleAddress
          }
    address :: a -> IORes Address
    address _ = return simpleAddress
    simpleAddress =
      Address {city = const $ pure "Hamburg", street = const $ pure "Street", houseNumber = const $ pure 20}


gqlRoot :: GQLRootResolver IO () () Query () ()
gqlRoot = GQLRootResolver {queryResolver = resolveQuery, mutationResolver = return (), subscriptionResolver = return ()}

thApi :: B.ByteString -> IO B.ByteString
thApi = interpreter gqlRoot
