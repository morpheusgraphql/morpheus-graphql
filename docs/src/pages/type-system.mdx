import SEO from "../components/seo";
import { Section } from "../components/section";

<SEO
  title="Type System"
  keywords={["Morpheus GraphQL", "GraphQL", "Haskell", "Type System"]}
/>

# Type System

<Section id="enums"> Enums </Section>

Data types where all constructors are empty are derived as GraphQL enums.

```haskell
data City
  = Athens
  | Sparta
  | Corinth
  | Delphi
  | Argos
  deriving
    ( Generic
    , GQLType
    )
```

<Section id="Unions">Unions</Section>

To use union type, all you have to do is derive the `GQLType` class. Using GraphQL [_fragments_](https://graphql.org/learn/queries/#fragments), the arguments of each data constructor can be accessed from the GraphQL client.

```haskell
data Character
  = CharacterDeity Deity -- will be unwrapped, since Character + Deity = CharacterDeity
  | SomeDeity Deity -- will be wrapped since Character + Deity != SomeDeity
  | Creature { creatureName :: Text, creatureAge :: Int }
  | Demigod Text Text
  | Zeus
  deriving (Generic, GQLType)
```

where `Deity` is an object.

As we see, there are different kinds of unions. `Morpheus` handles them all.

This type will be represented as

```graphql
union Character = Deity | SomeDeity | Creature | SomeMulti | Zeus

type SomeDeity {
  _0: Deity!
}

type Creature {
  creatureName: String!
  creatureAge: Int!
}

type Demigod {
  _0: Int!
  _1: String!
}

type Zeus {
  _: Unit!
}
```

By default, union members will be generated with wrapper objects.
There is one exception to this: if a constructor of a type is the type name concatenated with the name of the contained type, it will be referenced directly.
That is, given:

```haskell
data Song = { songName :: Text, songDuration :: Float } deriving (Generic, GQLType)

data Skit = { skitName :: Text, skitDuration :: Float } deriving (Generic, GQLType)

data WrappedNode
  = WrappedSong Song
  | WrappedSkit Skit
  deriving (Generic, GQLType)

data NonWrapped
  = NonWrappedSong Song
  | NonWrappedSkit Skit
  deriving (Generic, GQLType)

```

You will get the following schema:

```graphql
# has wrapper types
union WrappedNode = WrappedSong | WrappedSkit

# is a direct union
union NonWrapped = Song | Skit

type WrappedSong {
  _0: Song!
}

type WrappedSKit {
  _0: Skit!
}

type Song {
  songDuration: Float!
  songName: String!
}

type Skit {
  skitDuration: Float!
  skitName: String!
}
```

- for all other unions will be generated new object type. for types without record syntax, fields will be automatically indexed.

- all empty constructors in union will be summed in type `<tyConName>Enum` (e.g `CharacterEnum`), this enum will be wrapped in `CharacterEnumObject` and added to union members.

<Section id="scalars"> Scalars </Section>

To use custom scalar types, you need to provide implementations for `parseValue` and `serialize` respectively.

```haskell
data Odd = Odd Int  deriving (Generic)

instance DecodeScalar Euro where
  decodeScalar (Int x) = pure $ Odd (... )
  decodeScalar _ = Left "invalid Value!"

instance EncodeScalar Euro where
  encodeScalar (Odd value) = Int value

instance GQLType Odd where
  type KIND Odd = SCALAR
```

<Section id="interfaces">Interfaces</Section>

1. defining interface with Haskell Types (runtime validation):

   ```haskell
     -- interface is just regular type derived as interface
   newtype Person m = Person {name ::  m Text}
     deriving (Generic)

   instance GQLType (Person m) where
     type KIND (Person m) = INTERFACE

   -- with GQLType user can links interfaces to implementing object
   instance GQLType Deity where
     implements _ = [interface (Proxy @Person)]
   ```

2. defining with `importGQLDocument` and `DSL` (compile time validation):

   ```graphql
   interface Account {
     name: String!
   }

   type User implements Account {
     name: String!
   }
   ```
