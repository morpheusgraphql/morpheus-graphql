[
  {
    "path": "fragment/loopingFragment",
    "description": "fail when: fragment directly or indirectly references itself"
  },
  {
    "path": "arguments/unknownArguments",
    "description": "fail when: argument on field is not recognised by the schema"
  },
  {
    "path": "arguments/nameConflict",
    "description": "fail when: argument names on field are not unique"
  },
  {
    "path": "arguments/undefinedArgument",
    "description": "fail when: required argument is not defined in selection "
  },
  {
    "path": "selection/unknownField",
    "description": "fail when: selected field does not exist on type"
  },
  {
    "path": "selection/hasNoSubFields",
    "description": "fail when: selected subFields on non object type"
  },
  {
    "path": "selection/mustHaveSubFields",
    "description": "fail when: is not selected subFields on object type"
  },
  {
    "path": "selection/mergeConflict/arguments",
    "description": "fail when: selections with on same fields have different arguments"
  },
  {
    "path": "selection/mergeConflict/union",
    "description": "fail when: conflicting union"
  },
  {
    "path": "selection/mergeUnionSelection",
    "description": "merge union selections"
  },
  {
    "path": "selection/mergeConflict/alias",
    "description": "fail when: selections on different fields have same alias"
  },
  {
    "path": "selection/AliasResolve",
    "description": "resolves same field with different name"
  },
  {
    "path": "selection/AliasUnknownField",
    "description": "fail when: selected field in alias does not exist on type"
  },
  {
    "path": "fragment/inlineFragment",
    "description": "returns field selected by inline Fragment"
  },
  {
    "path": "fragment/inlineFragmentTypeMismatch",
    "description": "fail when: inline fragment type is incompatible with object type"
  },
  {
    "path": "fragment/cannotBeSpreadOnType",
    "description": "fail when: fragment type is incompatible with object type"
  },
  {
    "path": "fragment/unusedFragment",
    "description": "fail when: defined fragment is not used query"
  },
  {
    "path": "fragment/nameCollision",
    "description": "fail when: fragments are defined with same name"
  },
  {
    "path": "fragment/conditionTypeViolation",
    "description": "fail when: condtion type is not an Object"
  },
  {
    "path": "fragment/unknownConditionType",
    "description": "fail when: condtion type is not defined by schema"
  },
  {
    "path": "parsing/duplicatedFields",
    "description": "fail when: user supplies duplicated fields"
  },
  {
    "path": "parsing/invalidFields",
    "description": "fail when: user supplies invalid fields"
  },
  {
    "path": "parsing/invalidNotNullOperator",
    "description": "fail when: user supplies '@' instead of '!'"
  },
  {
    "path": "parsing/missingCloseBrace",
    "description": "fail when: user misses out a closing '}'"
  },
  {
    "path": "parsing/generousSpaces",
    "description": "returns query even when spacing is extremely liberal"
  },
  {
    "path": "parsing/complex",
    "description": "returns on a complex query that exercises all features"
  },
  {
    "path": "parsing/extraCommas",
    "description": "fails on a query with too many commas"
  },
  {
    "path": "parsing/inputListValues",
    "description": "returns query when input list values are separated by newlines or commas"
  },
  {
    "path": "parsing/notNullSpacing",
    "description": "returns on a query that pads all '!' chars with whitespace"
  },
  {
    "path": "introspection/interface",
    "description": "interface must be visible in introspection"
  },
  {
    "path": "introspection/schemaTypes/__Type",
    "description": "benchmark  __Type"
  },
  {
    "path": "introspection/schemaTypes/__InputValue",
    "description": "benchmark  __InputValue"
  },
  {
    "path": "introspection/schemaTypes/__Field",
    "description": "benchmark  __Field"
  },
  {
    "path": "introspection/schemaTypes/__EnumValue",
    "description": "benchmark  __EnumValue"
  },
  {
    "path": "introspection/schemaTypes/__TypeKind",
    "description": "benchmark  __TypeKind"
  },
  {
    "path": "introspection/schemaTypes/__Directive",
    "description": "benchmark  __Directive"
  },
  {
    "path": "introspection/schemaTypes/__DirectiveLocation",
    "description": "benchmark  __DirectiveLocation"
  },
  {
    "path": "introspection/schemaTypes/__Schema",
    "description": "benchmark  __Schema"
  },
  {
    "path": "introspection/defaultTypes/String",
    "description": "benchmark  String"
  },
  {
    "path": "introspection/defaultTypes/Boolean",
    "description": "benchmark  Boolean"
  },
  {
    "path": "introspection/defaultTypes/Int",
    "description": "benchmark  Int"
  },
  {
    "path": "introspection/defaultTypes/Float",
    "description": "benchmark Float"
  },
  {
    "path": "introspection/defaultTypes/ID",
    "description": "benchmark ID"
  },
  {
    "path": "introspection/kinds/OBJECT",
    "description": "test introspection of OBJECT kind with args, NonNull and List wrappers"
  },
  {
    "path": "introspection/kinds/INPUT_OBJECT",
    "description": "test introspection of INPUT_OBJECT kind"
  },
  {
    "path": "introspection/kinds/SCALAR",
    "description": "test introspection of SCALAR kind"
  },
  {
    "path": "introspection/kinds/ENUM",
    "description": "test introspection of ENUM kind"
  },
  {
    "path": "introspection/kinds/UNION",
    "description": "test introspection of UNION kind"
  },
  {
    "path": "parsing/singleLineComments",
    "description": "parses single line comments"
  },
  {
    "path": "parsing/AnonymousOperation/query",
    "description": "parse anonymous query"
  },
  {
    "path": "parsing/AnonymousOperation/mutation",
    "description": "parse anonymous mutation"
  },
  {
    "path": "parsing/AnonymousOperation/subscription",
    "description": "parse anonymous subscription"
  },
  {
    "path": "parsing/directive/operation",
    "description": "parse operation directives"
  },
  {
    "path": "parsing/directive/selection",
    "description": "parse directives on selection fields"
  },
  {
    "path": "parsing/directive/notOnArgument",
    "description": "fail when:  directives are used in arguments"
  },
  {
    "path": "parsing/directive/notOnVariable",
    "description": "fail when: directive is used in Variable Definition"
  },
  {
    "path": "parsing/numbers",
    "description": "parse signed numbers and numbers with expotential"
  },
  {
    "path": "introspection/description/object",
    "description": "check object descriptions, type, field, args"
  },
  {
    "path": "introspection/description/inputObject",
    "description": "check inputObject descriptions, type, field"
  },
  {
    "path": "introspection/description/union",
    "description": "check union descriptions, type"
  },
  {
    "path": "introspection/description/enum",
    "description": "check enum descriptions, type, enumValue"
  },
  {
    "path": "introspection/deprecated/enumValue",
    "description": "check if deprecated works with enumValue"
  },
  {
    "path": "introspection/deprecated/field",
    "description": "check if deprecated works with object fields"
  },
  {
    "path": "failure/resolveFailure",
    "description": "test failed resolvers"
  },
  {
    "path": "selection/__typename",
    "description": "test __typename on object types"
  },
  {
    "path": "selection/mergeSelection",
    "description": "merge selection on same fields"
  },
  {
    "path": "selection/subscription/singleTopLevelField/fail",
    "description": "fail if subscription selects more then one top level field."
  },
  {
    "path": "selection/subscription/singleTopLevelField/failAnonymous",
    "description": "fail if subscription selects more then one top level field. (for anonymous subscription)"
  }
]
